# NGS-analysis-for-Somatic-Mutation-calling
This is a Pipeline for Somatic mutation calling using Panel of normals to exclude germline variants
```markdown
# Somatic NGS Pipeline (Tumor–Normal, PoN, Mutect2)

A reproducible Snakemake workflow to call somatic variants from NGS data using:
Trimmomatic → FastQC → BWA-MEM → Picard/Samtools/Sambamba → GATK Mutect2 + FilterMutectCalls → VCF QC.

## Key Features
- Tumor–normal calling with **Panel of Normals (PoN)** and **germline resource**.
- Low‑VAF sensitivity oriented (e.g., reliable at ~5% VAF with high depth).
- Modular rules and single `config.yaml`.
- Conda environment for full reproducibility.
- CI (GitHub Actions) dry‑runs to validate PRs.

## Repository Structure
See the tree in the project root for directories and files.

## Requirements
- Linux/macOS
- Conda (mamba recommended)
- Snakemake ≥7

## Input Sheets
- `config/samples.tsv` — sample metadata (one row per sample).
- `config/pairs.tsv` — mapping of tumor ↔ normal samples.

## Reference & Resources
Place under `resources/reference/`:
- `wg.fa` (hg38 FASTA)
- Indexes: `wg.fa.fai`, BWA index `hg38bwaidx.*`, GATK dict `wg.dict`
- Germline resource: `somatic-hg38_af-only-gnomad.hg38.vcf.gz` (+ `.tbi`)
- **Optional PoN**: `somatic-hg38_1000g_pon.hg38.vcf.gz` (+ `.tbi`) or a custom PoN generated by the workflow.

## Usage
```bash
snakemake --use-conda --cores 16 -p
```

## Outputs (default)
- QC: `results/qc/fastqc/*.html`
- Trimmed FASTQs: `results/trimmed/{sample}/*.trim.fastq.gz`
- Deduped BAMs: `results/bam/{sample}/{sample}.final_sorted_deduped.bam`
- Mutect2 VCF (tumor–normal): `results/mutect2/{pair}.somatic.vcf.gz`
- Filtered VCF: `results/mutect2/{pair}.somatic.filtered.vcf.gz`
- Optional PoN: `results/pon/bladder_pon.vcf.gz`

## Citation / Acknowledgements
- Trimmomatic, FastQC, BWA, Picard, Samtools, Sambamba, GATK, bcftools, vcftools.
- Built by Raiyan Hosen (University of Dhaka).

## License
MIT (see `LICENSE`).

```
# Paths
reference_dir: "resources/reference"
adapters: "resources/adapters/TruSeq3-PE-2.fa"

# Reference files (inside reference_dir)
reference_fasta: "wg.fa"            # e.g., hg38 concatenated FASTA
reference_dict: "wg.dict"           # picard-created dict
bwa_index_prefix: "hg38bwaidx"      # created by bwa index

# Resources
germline_resource: "somatic-hg38_af-only-gnomad.hg38.vcf.gz"
panel_of_normals: "somatic-hg38_1000g_pon.hg38.vcf.gz"  # or results/pon/bladder_pon.vcf.gz

# Trimming
trimmomatic_threads: 8
trimmomatic_params:
  slidingwindow: "4:20"
  minlen: 25
  illumina_clip: "2:30:10:2"

# Alignment
bwa_threads: 16

# Post-processing
mapq_min: 20

# Mutect2
mutect2_threads: 8
mutect2_mode: "tumor_normal"  # options: tumor_normal | tumor_only | build_pon

# PoN creation options
pon_min_samples: 2  # minimum normals required to keep a site
```

---

## `config/samples.tsv`

```tsv
# sample_id    type      fastq_r1                          fastq_r2
DU_001         normal    data/fastq/DU_001_1.fastq.gz      data/fastq/DU_001_2.fastq.gz
DU_T_001       tumor     data/fastq/DU_T_001_1.fastq.gz    data/fastq/DU_T_001_2.fastq.gz
```

---

## `config/pairs.tsv`

```tsv
# pair_id    tumor_id   normal_id
P001         DU_T_001   DU_001
```

---

## `workflow/Snakefile`

```python
# Master Snakefile: includes modular rules
include: "rules/qc.smk"
include: "rules/trim.smk"
include: "rules/ref.smk"
include: "rules/align.smk"
include: "rules/postproc.smk"
include: "rules/mutect2.smk"
include: "rules/vcfqc.smk"

import pandas as pd

SAMPLES = pd.read_csv("config/samples.tsv", sep="\t", comment="#")
PAIRS = pd.read_csv("config/pairs.tsv", sep="\t", comment="#")

SAMPLE_IDS = SAMPLES["sample_id"].tolist()
PAIR_IDS = PAIRS["pair_id"].tolist()

rule all:
    input:
        # QC
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=SAMPLE_IDS),
        expand("results/qc/fastqc/{sample}_R2_fastqc.html", sample=SAMPLE_IDS),
        # Final BAMs
        expand("results/bam/{sample}/{sample}.final_sorted_deduped.bam", sample=SAMPLE_IDS),
        # Somatic calls (filtered)
        expand("results/mutect2/{pair}.somatic.filtered.vcf.gz", pair=PAIR_IDS)
```

---

## `workflow/rules/trim.smk`

```python
import yaml
cfg = yaml.safe_load(open("config/config.yaml"))

def fq_paths(wildcards):
    row = SAMPLES[SAMPLES["sample_id"] == wildcards.sample].iloc[0]
    return row["fastq_r1"], row["fastq_r2"]

rule trim_pe:
    input:
        fq_paths
    output:
        r1_paired = "results/trimmed/{sample}/{sample}_R1.trim.fastq.gz",
        r1_unpaired = "results/trimmed/{sample}/{sample}_R1.unpaired.fastq.gz",
        r2_paired = "results/trimmed/{sample}/{sample}_R2.trim.fastq.gz",
        r2_unpaired = "results/trimmed/{sample}/{sample}_R2.unpaired.fastq.gz"
    threads: cfg["trimmomatic_threads"]
    conda: "../envs/environment.yaml"
    params:
        adapters = f"{cfg['adapters']}",
        sw = cfg["trimmomatic_params"]["slidingwindow"],
        minlen = cfg["trimmomatic_params"]["minlen"],
        iclip = cfg["trimmomatic_params"]["illumina_clip"]
    shell:
        r"""
        trimmomatic PE -threads {threads} \
          {input[0]} {input[1]} \
          {output.r1_paired} {output.r1_unpaired} \
          {output.r2_paired} {output.r2_unpaired} \
          ILLUMINACLIP:{params.adapters}:{params.iclip} \
          SLIDINGWINDOW:{params.sw} MINLEN:{params.minlen}
        """
```

---

## `workflow/rules/qc.smk`

```python
rule fastqc_r1:
    input: "results/trimmed/{sample}/{sample}_R1.trim.fastq.gz"
    output: "results/qc/fastqc/{sample}_R1_fastqc.html"
    conda: "../envs/environment.yaml"
    shell: "fastqc {input} -o results/qc/fastqc/"

rule fastqc_r2:
    input: "results/trimmed/{sample}/{sample}_R2.trim.fastq.gz"
    output: "results/qc/fastqc/{sample}_R2_fastqc.html"
    conda: "../envs/environment.yaml"
    shell: "fastqc {input} -o results/qc/fastqc/"
```

---

## `workflow/rules/ref.smk`

```python
import yaml, os
cfg = yaml.safe_load(open("config/config.yaml"))
REFDIR = cfg["reference_dir"]

rule bwa_index:
    input: os.path.join(REFDIR, cfg["reference_fasta"])
    output:
        expand(os.path.join(REFDIR, cfg["bwa_index_prefix"] + ext),
               ext=[".amb",".ann",".bwt",".pac",".sa"])
    conda: "../envs/environment.yaml"
    shell:
        r"""
        bwa index -p {RESDIR}/{cfg[bwa_index_prefix]} -a bwtsw {input}
        """

rule picard_dict:
    input: os.path.join(REFDIR, cfg["reference_fasta"])
    output: os.path.join(REFDIR, cfg["reference_dict"])
    conda: "../envs/environment.yaml"
    shell:
        r"""
        gatk CreateSequenceDictionary \
          -R {input} \
          -O {output}
        """
```

---

## `workflow/rules/align.smk`

```python
import yaml
cfg = yaml.safe_load(open("config/config.yaml"))
REFDIR = cfg["reference_dir"]
BWAIDX = os.path.join(REFDIR, cfg["bwa_index_prefix"])

rule bwa_mem:
    input:
        r1 = "results/trimmed/{sample}/{sample}_R1.trim.fastq.gz",
        r2 = "results/trimmed/{sample}/{sample}_R2.trim.fastq.gz",
        idx = expand(BWAIDX + "{ext}", ext=[".bwt",".sa"])  # ensure index exists
    output: temp("results/bam/{sample}/{sample}.unsorted.bam")
    threads: cfg["bwa_threads"]
    conda: "../envs/environment.yaml"
    shell:
        r"""
        mkdir -p results/bam/{wildcards.sample}
        bwa mem -t {threads} {BWAIDX} {input.r1} {input.r2} | \
          samtools view -S -b - > {output}
        """
```

---

## `workflow/rules/postproc.smk`

```python
import yaml
cfg = yaml.safe_load(open("config/config.yaml"))

rule add_read_groups:
    input: "results/bam/{sample}/{sample}.unsorted.bam"
    output: temp("results/bam/{sample}/{sample}.rg.bam")
    conda: "../envs/environment.yaml"
    shell:
        r"""
        gatk AddOrReplaceReadGroups \
          -I {input} -O {output} \
          --RGID 1 --RGLB lib1 --RGPL illumina --RGPU unit1 --RGSM {wildcards.sample}
        """

rule sort_bam:
    input: "results/bam/{sample}/{sample}.rg.bam"
    output: temp("results/bam/{sample}/{sample}.sorted.bam")
    conda: "../envs/environment.yaml"
    shell: "samtools sort {input} -o {output}"

rule filter_mapq:
    input: "results/bam/{sample}/{sample}.sorted.bam"
    output: temp("results/bam/{sample}/{sample}.mapq{mapq}.bam")
    params: mapq=cfg["mapq_min"]
    conda: "../envs/environment.yaml"
    shell:
        "samtools view -bq {params.mapq} {input} > {output}"

rule markdup_sambamba:
    input: "results/bam/{sample}/{sample}.mapq{mapq}.bam"
    output: "results/bam/{sample}/{sample}.final_sorted_deduped.bam"
    params: mapq=cfg["mapq_min"]
    conda: "../envs/environment.yaml"
    shell:
        "sambamba markdup -r {input} {output}"
```

---

## `workflow/rules/mutect2.smk`

```python
import yaml, os
cfg = yaml.safe_load(open("config/config.yaml"))
REFDIR = cfg["reference_dir"]
REF = os.path.join(REFDIR, cfg["reference_fasta"])
DICT = os.path.join(REFDIR, cfg["reference_dict"])
GERM = os.path.join(REFDIR, cfg["germline_resource"])
PON  = os.path.join(REFDIR, cfg["panel_of_normals"])

def tumor_bam(wildcards):
    t = PAIRS.loc[PAIRS["pair_id"] == wildcards.pair, "tumor_id"].iloc[0]
    return f"results/bam/{t}/{t}.final_sorted_deduped.bam"

def normal_bam(wildcards):
    n = PAIRS.loc[PAIRS["pair_id"] == wildcards.pair, "normal_id"].iloc[0]
    return f"results/bam/{n}/{n}.final_sorted_deduped.bam"

def normal_id(wildcards):
    return PAIRS.loc[PAIRS["pair_id"] == wildcards.pair, "normal_id"].iloc[0]

rule mutect2_tn:
    input:
        ref = REF,
        dict = DICT,
        germ = GERM,
        pon  = PON,
        tumor = tumor_bam,
        normal = normal_bam
    output:
        vcf = "results/mutect2/{pair}.somatic.vcf.gz",
        idx = "results/mutect2/{pair}.somatic.vcf.gz.tbi"
    threads: cfg["mutect2_threads"]
    conda: "../envs/environment.yaml"
    shell:
        r"""
        gatk Mutect2 \
          -R {input.ref} \
          -I {input.tumor} \
          -I {input.normal} \
          -normal {normal_id} \
          --germline-resource {input.germ} \
          --panel-of-normals {input.pon} \
          -O {output.vcf}
        """

rule filter_mutect_calls:
    input: vcf = "results/mutect2/{pair}.somatic.vcf.gz", ref = REF
    output: "results/mutect2/{pair}.somatic.filtered.vcf.gz"
    conda: "../envs/environment.yaml"
    shell:
        "gatk FilterMutectCalls -R {input.ref} -V {input.vcf} -O {output}"
```

---

## `workflow/rules/vcfqc.smk`

```python
rule vcftools_site_quality:
    input: "results/mutect2/{pair}.somatic.vcf.gz"
    output: "results/vcfqc/{pair}_sitequality.log"
    conda: "../envs/environment.yaml"
    shell:
        "vcftools --gzvcf {input} --site-quality --out results/vcfqc/{wildcards.pair}_sitequality"
```

> Add more vcftools/bcftools filters here as needed (minQ, biallelic, indels-only, etc.).

---

## `workflow/envs/environment.yaml`

```yaml
name: somatic-ngs
channels:
  - conda-forge
  - bioconda
dependencies:
  - python>=3.9
  - snakemake>=7
  - trimmomatic=0.39
  - fastqc
  - bwa=0.7.17
  - samtools
  - gatk4
  - picard
  - sambamba
  - bcftools
  - vcftools
  - htslib
  - tabix
  - pandas
  - pyyaml
```

---

## `.github/workflows/ci.yaml`

```yaml
name: snakemake-dry-run

on:
  push:
  pull_request:

jobs:
  dry-run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup mamba
        uses: mamba-org/setup-micromamba@v2
        with:
          micromamba-version: "latest"
          environment-file: workflow/envs/environment.yaml
          cache-environment: true
          cache-downloads: true
          init-shell: bash
      - name: Dry run
        shell: bash -l {0}
        run: |
          snakemake -n -p
```

---

## `.gitignore`

```gitignore
# Snakemake & results
.results/
results/
log/
work/
.snakemake/

# Conda envs
env/
*.conda

# Reference / large files
resources/reference/*.tar.gz
resources/reference/*.fa
resources/reference/*.fa.*
resources/reference/*.dict
resources/reference/*.vcf*
```

---

## `LICENSE` (MIT)

```text
MIT License

Copyright (c) 2025 Raiyan Hosen

Permission is hereby granted, free of charge, to any person obtaining a copy
...
```

---

## Notes & Options

- **PoN creation**: If you want the workflow to **build a custom PoN**, we can add rules that:
  1) run Mutect2 in tumor‑only mode on each normal,  
  2) `bcftools merge` → `tabix`,  
  3) `gatk CreateSomaticPanelOfNormals` to produce `results/pon/bladder_pon.vcf.gz`.  
  Tell me your number of normal samples, and I’ll add those rules.

- **Additional callers**: We can plug in **Strelka2**, **VarScan2**, or **Lancet** as optional rules and create a consensus set.

- **MultiQC**: If you want a single QC report, I can add **MultiQC** to parse FastQC, samtools stats, and Mutect2 logs.

---
